/**
 * {sprite, position, speed} = options
 * @param {string} sprite - url of the sprite to get via Resource;
 * @param {object} position - x, y position of the target;
 * @param {speed} position - target basic speed, not fixed by delta tickTime;
 */
var BasicClass = function(options){
    this.sprite = options['sprite'];
    this.position = {
        x: options['position']['x'],
        y: options['position']['y']
    };
    this.speed = options['speed']
};

/**
 * this function is called to render target sprite to target position.
 * if the target has a property of 'reversed', it will reverse the canvas context to render.
 */
BasicClass.prototype.render = function () {
    if (this.reversed === true) {
        ctx.translate(606, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(Resources.get(this.sprite), 505 - this.position['x'], this.position['y']);
        ctx.translate(606, 0);
        ctx.scale(-1, 1);
    } else {
        ctx.drawImage(Resources.get(this.sprite), this.position['x'], this.position['y']);
    }
};

/**
 * this function is called to check if target has collisions with another target
 */
BasicClass.prototype.checkCollisions = function (targetPosition) {
    var deltaX = this.position['x'] - targetPosition['x'],
        deltaY = this.position['y'] - (targetPosition['y'] - 5)
    return Math.abs(deltaX) < 50 && Math.abs(deltaY) < 20;
};

// Enemies our player must avoid
/**
 * {reversed, row} options 
 * @param {boolean} reversed - to control if the Enemy moves from right to left
 * @param {number} row - which row does the enemy move in
 * sprite, speed, position are generated by BasicClass
 */
var Enemy = function (options) {
    // Variables applied to each of our instances go here,
    // we've provided one for you to get started

    // The image/sprite for our enemies, this uses
    // a helper we've provided to easily load images
    this.row = options['row'];
    this.reversed = options['reversed'] || false;
    BasicClass.call(this, {
        sprite: 'images/enemy-bug.png',
        speed: this.row < 3 ? util.getRandomScope(1, 5) * 200 : util.getRandomScope(1, 5) * 100,
        position: {
            x: this.reversed === true ? 505 : 0,
            y: this.row * 83 - 45
        }
    })
};

inherit(Enemy, BasicClass);

/**
 * this function is called to judge if enemy is available during the current tick.
 */
Enemy.prototype.available = function () {
    return this.reversed ? this.position['x'] > 0 : this.position['x'] < 505;
};

// Update the enemy's position, required method for game
// Parameter: dt, a time delta between ticks
Enemy.prototype.update = function (dt) {
    // You should multiply any movement by the dt parameter
    // which will ensure the game runs at the same speed for
    // all computers.
    if (this.reversed === true) {
        this.position['x'] -= this.speed * dt;
    } else {
        this.position['x'] += this.speed * dt;
    }
};

// Draw the enemy on the screen, required method for game
Enemy.prototype.render = function () {
    if (this.reversed === true) {
        ctx.translate(606, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(Resources.get(this.sprite), 505 - this.position['x'], this.position['y']);
        ctx.translate(606, 0);
        ctx.scale(-1, 1);
    } else {
        ctx.drawImage(Resources.get(this.sprite), this.position['x'], this.position['y']);
    }
};

/**
 * {char} = options
 * @param{string} char - name of charactor
 * {object} moving - it changes when input is handled, somehow it debounced the input because user input is not accepted
 * when moving.distance is not 0.
 * sprite, speed, position are generated by BasicClass
 */
var Player = function (options) {
    BasicClass.call(this, {
        sprite: 'images/char-' + options['char'] + '.png',
        speed: 500,
        position: {
            x: 303,
            y: 7 * 83 - 40
        }
    });
    this.moving = {
        distance: 0,
        direction: null
    };
};
inherit(Player, BasicClass);

/**
 * this function is a bit different from enemy's because we need a smooth transition between every step, which is triggered
 * by user input. so I wrote a function to handle move.
 */
Player.prototype.update = function (dt) {
    var tickDistance = this.speed * dt
    this.Handlemove(tickDistance);
};

/**
 * this function turned user input to target moving distance and direction.
 */
Player.prototype.handleInput = function (direction) {
    if (this.moving['distance'] <= 0 && this.moveAvailable()[direction]) {
        switch (direction) {
            case 'left':
                this.moving = {
                    distance: 101,
                    direction: direction
                };
                break;
            case 'right':
                this.moving = {
                    distance: 101,
                    direction: direction
                };
                break;
            case 'up':
                this.moving = {
                    distance: 83,
                    direction: direction
                };
                break;
            case 'down':
                this.moving = {
                    distance: 83,
                    direction: direction
                };
                break;
        }
    }
};

// put win judgement here
Player.prototype.checkWin = function () {
    return this.position['y'] == 43;
};

/**
 * this makes highScore not recorded unless you survive and win the game!!!!
 */
Player.prototype.win = function () {
    winning = true;
    highScore = highScore < score ? score : highScore;
};

/**
 * this function is called to limit user move within the map scope.
 */
Player.prototype.moveAvailable = function () {
    return {
        left: this.position['x'] > 0,
        right: this.position['x'] < 505,
        up: this.position['y'] > 43,
        down: this.position['y'] < 541
    };
};

/**
 * this function handled the position mutation between one input and the next.
 * @param {number} distance - distance calculated by player speed and current tick delta time.
 */
Player.prototype.Handlemove = function (distance) {
    var delta = this.moving['distance'] - distance;
    if (this.moving['distance'] > 0) {
        if (delta < 0) {
            distance = this.moving['distance'];
        }
        switch (this.moving['direction']) {
            case 'left':
                this.position['x'] -= distance;
                break;
            case 'right':
                this.position['x'] += distance;
                break;
            case 'up':
                this.position['y'] -= distance;
                break;
            case 'down':
                this.position['y'] += distance;
                break;
        }
        this.moving['distance'] -= distance;
    }
};

// defniend gems to count score
var Gems = function (options) {
    var gemInfo = gemSet[options['type']];
    BasicClass.call(this, {
        'sprite': 'images/gem-' + gemInfo['gemNm'] + '.png',
        'position': {
            x: options['col'] * 101,
            y: options['row'] * 83 - 35
        }
    });
    this.score = gemInfo['score'];
};

inherit(Gems, BasicClass);

// Now instantiate your objects.
// Place all enemy objects in an array called allEnemies
// Place the player object in a variable called player

/**
 * {array} allEnemies - array to restore all the enemy-bugs instances;
 * {object} player - a Player instance;
 * {object} gems - a Gems instance;
 * {object} gemSet - set img and score to different gems;
 * {number} score - to record score for current round game;
 * {number} highScore - to record highest score for history;
 * {boolean} winning - show if the player wins, to trigger game ends and high score accounting;
 * {string} level - to define level for the current round game;
 * {object} levelConfig - turn level into detail features;
 * {function} resetGame - a function to bind with reset DOM button;
 */
var allEnemies,
    player,
    gems,
    gemSet = {
        1: {
            gemNm: 'blue',
            score: 200,
        },
        2: {
            gemNm: 'green',
            score: 300,
        },
        3: {
            gemNm: 'orange',
            score: 500,
        }
    },
    score = 0,
    highScore = 0,
    winning,
    level = 'lunatic',
    levelConfig = {
        'easy': {
            enemy_count: 5,
            enemy_two_direction: true
        },
        'medium': {
            enemy_count: 10,
            enemy_two_direction: true
        },
        'hard': {
            enemy_count: 12,
            enemy_two_direction: false
        },
        'lunatic': {
            enemy_count: 15,
            enemy_two_direction: false
        }
    },
    resetGame;

// This listens for key presses and sends the keys to your
// Player.handleInput() method. You don't need to modify this.
document.addEventListener('keydown', function (e) {
    var allowedKeys = {
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
    };
    player.handleInput(allowedKeys[e.keyCode]);
});

// use this function to implement inherit from superClasses prototype
function inherit(subClass,superClass) {
   subClass.prototype = Object.create(superClass.prototype); // delegate to prototype
   subClass.prototype.constructor = subClass; // set constructor on prototype
}
